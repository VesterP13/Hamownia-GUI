import tkinter
from tkinter import messagebox
from tkinter import *
import customtkinter
import serial
import time
import math
from datetime import datetime
import pandas as pd
import os

#USTAWIENIA OKNA
app_tk = tkinter.Tk()
app_tk.geometry("1024x600")
app_tk.title("PUT POWERTRAIN DYNAMOMETER")
app_tk.resizable(False, False)
photobackground = PhotoImage(file="C:\Hamownia\predkosciomierzm2.png")
my_canvas = Canvas(app_tk, width=1024, height=600)
my_canvas.pack(fill='both', expand=True)
my_canvas.create_image(0,0, image=photobackground, anchor="nw")

#ZMIENNE
ser = serial.Serial('COM3', 9600)
arduinoValues = []
rpm1Counts = []
rpm2Counts = []
rpm3Counts = []
rpm4Counts = []
temp1Values = []
times = []
frequency = 1
measuring = False

#FUNKCJE POMIARU
def arduinoReading():
    line = ser.readline().decode('utf-8').rstrip()
    values = line.split(';')  # Podziel linijkę na wartości
    for i in values:
        arduinoValues.append(i)
    values.clear()

def arduinoValuesAllocation():
    rpm1Counts.append(arduinoValues[0])
    rpm2Counts.append(arduinoValues[1])
    rpm3Counts.append(arduinoValues[2])
    rpm4Counts.append(arduinoValues[3])
    temp1Values.append(arduinoValues[4])
    arduinoValues.clear()
    teraz = datetime.now()
    text_area.insert(customtkinter.END, rpm1Counts[-1] + ";" + rpm2Counts[-1] + ";" + rpm3Counts[-1] + ";" + rpm4Counts[-1] + ";" + temp1Values[-1] + ";" + teraz.strftime("%H:%M:%S") + ";"  + "\n")
    times.append(teraz.strftime("%H:%M:%S"))
    updateDisplayText(rpm1Counts[-1])
    update_arrows()

def measurment():
    global measuring
    if ser.in_waiting > 0 and measuring:
        arduinoReading()  # Czyta wartości z arduino i dzieli do arduinoValues
        arduinoValuesAllocation()  # Przydziela wartości z arduino do wartości parametrów
    app_tk.after(frequency, measurment)  # Opóźnij funkcję o częstotliwość

def stopMeasurement():
    global measuring
    measuring = False

def startMeasurement():
    ser.flushInput()  # Opróżnij bufor portu szeregowego
    global measuring
    measuring = True
    measurment()

#FUNKCJE ZAPYTANIA
class CustomAskQuestion(tkinter.Toplevel):
    def __init__(self, parent, title, question):
        super().__init__(parent)
        self.title(title)
        self.geometry("300x100")
        self.result = None

        label = tkinter.Label(self, text=question)
        label.pack(pady=10)

        yes_button = tkinter.Button(self, text="Microsoft Excel (.xlsx)", command=self.answer_yes)
        yes_button.pack(side=tkinter.LEFT, padx=10)

        no_button = tkinter.Button(self, text="Plik tekstowy (.txt)", command=self.answer_no)
        no_button.pack(side=tkinter.RIGHT, padx=10)

    def answer_yes(self):
        self.result = "excel"
        self.destroy()

    def answer_no(self):
        self.result = "txt"
        self.destroy()
        
def custom_askquestion(title, question):
    dialog = CustomAskQuestion(app_tk, title, question)
    app_tk.wait_window(dialog)
    return dialog.result

#FUNKCJE PRZYCISKÓW
def startStopButton_function():
    if startStopButton.cget('text') == 'Start':
        startMeasurement()
        startStopButton.configure(text = 'Stop', fg_color = '#9c1208')
    else: 
        startStopButton.configure(text = 'Start', fg_color='#7fb310')
        stopMeasurement()

def saveButton_function():
    result = custom_askquestion("Zapis", "Wybierz format pliku.")
    if result == "excel":
        data = datetime.now()
        df = pd.DataFrame({
        'czas': times,
        'rpm1_silnik1': rpm1Counts,
        'rpm_silnik2': rpm2Counts,
        'rpm_silnik3': rpm3Counts,
        'rpm_silnik4': rpm4Counts,
        'temp. otoczenia': temp1Values
        })
        aktualna_data = datetime.now().strftime("%Y%m%d")
        # Tworzenie nazwy pliku w formacie 'YYYYMMDD.xlsx'
        nazwa_pliku = f"{aktualna_data}.xlsx"
        # Sprawdzanie, czy plik o danej nazwie już istnieje
        numer_cyfry = 1
        while os.path.exists(nazwa_pliku):
            numer_cyfry += 1
            nazwa_pliku = f"{aktualna_data}_{numer_cyfry}.xlsx"
        # Zapisywanie do pliku
        df.to_excel(nazwa_pliku, index=False)
    elif result == "txt":
        print("Zapis txt")
        df = pd.DataFrame({
        'czas': times,
        'rpm1_silnik1': rpm1Counts,
        'rpm_silnik2': rpm2Counts,
        'rpm_silnik3': rpm3Counts,
        'rpm_silnik4': rpm4Counts,
        'temp. otoczenia': temp1Values
        })
        # Uzyskanie aktualnej daty w formacie YYYYMMDD
        aktualna_data = datetime.now().strftime("%Y%m%d")

        # Tworzenie nazwy pliku w formacie 'YYYYMMDD.txt'
        nazwa_pliku = f"{aktualna_data}.txt"

        # Sprawdzanie, czy plik o danej nazwie już istnieje
        numer_cyfry = 1
        while os.path.exists(nazwa_pliku):
            numer_cyfry += 1
            nazwa_pliku = f"{aktualna_data}_{numer_cyfry}.txt"

        # Zapisywanie do pliku tekstowego
        df.to_csv(nazwa_pliku, index=False, sep='\t')
    else: print("Anulowano zapis.")

def resetButton_function():
    result = messagebox.askquestion("Pytanie", "Czy na pewno chcesz zresetować? \nStracisz niezapisane pomiary.")
    if result == "yes":
        rpm1Counts.clear()
        rpm2Counts.clear()
        rpm3Counts.clear()
        rpm4Counts.clear()
        temp1Values.clear()
        text_area.delete('1.0', tkinter.END)

def optionsButton_function():
    reveal_options()

#OKNO OPCJI
def reveal_options():
    options_window = tkinter.Tk()
    options_window.geometry("400x600")
    options_window.title("OPCJE")
    options_window.configure(bg=dark_theme_bg)
    options_window.resizable(False, False)

    optionsSaveButton = customtkinter.CTkButton(master=options_window, corner_radius=10, command=startStopButton_function, text = 'Zapisz', fg_color='#1F6AA5', width=200, height=50, font = ("Helvetica", 15))
    optionsSaveButton.place(relx=0.5, rely=0.7, anchor=tkinter.CENTER)

    optionsDefaultButton = customtkinter.CTkButton(master=options_window, corner_radius=10, command=startStopButton_function, text = 'Domyślne', fg_color='#1F6AA5', width=200, height=50, font = ("Helvetica", 15))
    optionsDefaultButton.place(relx=0.5, rely=0.8, anchor=tkinter.CENTER)

    optionsExitButton = customtkinter.CTkButton(master=options_window, corner_radius=10, command=startStopButton_function, text = 'Wyjdź', fg_color='#1F6AA5', width=200, height=50, font = ("Helvetica", 15))
    optionsExitButton.place(relx=0.5, rely=0.9, anchor=tkinter.CENTER)

# PRZYCISKI
startStopButton = customtkinter.CTkButton(master=app_tk, corner_radius=0, command=startStopButton_function, text = 'Start', fg_color='#7fb310', width=200, height=50, font = ("Helvetica", 15), background_corner_colors=('#1c2c5f','#1c2c5f','#1c2c5f','#1c2c5f'))
startStopButton.place(relx=0.5, rely=0.94, anchor=tkinter.CENTER)

saveButton = customtkinter.CTkButton(master=app_tk, corner_radius=0, command=saveButton_function, text = 'Zapisz', fg_color='#1a1a1a', width=180, height=40, font = ("Helvetica", 15))
saveButton.place(relx=0.7, rely=0.94, anchor=tkinter.CENTER)

resetButton = customtkinter.CTkButton(master=app_tk, corner_radius=0, command=resetButton_function, text = 'Reset', fg_color='#1a1a1a', width=180, height=40, font = ("Helvetica", 15))
resetButton.place(relx=0.3, rely=0.94, anchor=tkinter.CENTER)

optionsButton = customtkinter.CTkButton(master=app_tk, corner_radius=0, command=optionsButton_function, text = 'Opcje', fg_color='#1a1a1a', width=200, height=50, font = ("Helvetica", 15))
optionsButton.place(relx=0.5, rely=0.05, anchor=tkinter.CENTER)

# WYŚWIETLANIE WYNIKÓW
def updateDisplayText(value):
    my_canvas.itemconfig(rpmDisplay1, text = rpm1Counts[-1])
    my_canvas.itemconfig(rpmDisplay2, text = rpm2Counts[-1])
    my_canvas.itemconfig(rpmDisplay3, text = rpm3Counts[-1])
    my_canvas.itemconfig(rpmDisplay4, text = rpm4Counts[-1])
    my_canvas.itemconfig(tempDisplay1, text = (temp1Values[-1] + '°C'))

rpmDisplay1=my_canvas.create_text(282, 220, text = '0', font=("Avenir", 18), fill='white')
rpmDisplay1r=my_canvas.create_text(282, 240, text = 'rpm', font=("Avenir", 12), fill='white')

rpmDisplay2=my_canvas.create_text(793, 220, text = '0', font=("Avenir", 18), fill='white')
rpmDisplay2r=my_canvas.create_text(793, 240, text = 'rpm', font=("Avenir", 12), fill='white')

rpmDisplay3=my_canvas.create_text(282, 480, text = '0', font=("Avenir", 18), fill='white')
rpmDisplay3r=my_canvas.create_text(282, 500, text = 'rpm', font=("Avenir", 12), fill='white')

rpmDisplay4=my_canvas.create_text(793, 480, text = '0', font=("Avenir", 18), fill='white')
rpmDisplay4r=my_canvas.create_text(793, 500, text = 'rpm', font=("Avenir", 12), fill='white')

tempDisplay1=my_canvas.create_text(512, 300, text = ('0'), font=("Avenir", 28), fill='white')

# WSKAZANIE PRĘDKOŚCIOMIERZY
def update_arrows():
    global arrow1, arrow2, arrow3, arrow4
    new_angle1 = angle_transform(rpm1Counts[-1])
    new_angle2 = angle_transform(rpm2Counts[-1])
    new_angle3 = angle_transform(rpm3Counts[-1])
    new_angle4 = angle_transform(rpm4Counts[-1])
    arrow1 = change_angle(my_canvas, arrow1, 253, 144, 100, new_angle1)
    arrow2 = change_angle(my_canvas, arrow2, 770, 142, 100, new_angle2)
    arrow3 = change_angle(my_canvas, arrow3, 253, 406, 100, new_angle3)
    arrow4 = change_angle(my_canvas, arrow4, 770, 404, 100, new_angle4)

def change_angle(canvas, arrow, base_x, base_y, length, new_angle):
    my_canvas.delete(arrow)
    end_x = base_x + length * math.cos(math.radians(new_angle))
    end_y = base_y - length * math.sin(math.radians(new_angle))
    base1_x = base_x + 10 * math.cos(math.radians(new_angle + 90))
    base1_y = base_y - 10 * math.sin(math.radians(new_angle + 90))
    base2_x = base_x + 10 * math.cos(math.radians(new_angle - 90))
    base2_y = base_y - 10 * math.sin(math.radians(new_angle - 90))
    new_arrow_head = [(base1_x, base1_y), (base2_x, base2_y), (end_x, end_y)]
    new_arrow = canvas.create_polygon(new_arrow_head, fill='red')
    return new_arrow

def angle_transform(count):
    input_start = 0
    input_end = 20000
    output_start = 210
    output_end = -30
    output = output_start + ((output_end - output_start) / (input_end - input_start)) * (float(count) - input_start)
    return output

base_x, base_y = 397, 437
length = 100
angle = 210
end_x = base_x + length * math.cos(math.radians(angle))
end_y = base_y - length * math.sin(math.radians(angle))
base1_x = base_x + 10 * math.cos(math.radians(angle + 90))
base1_y = base_y - 10 * math.sin(math.radians(angle + 90))
base2_x = base_x + 10 * math.cos(math.radians(angle - 90))
base2_y = base_y - 10 * math.sin(math.radians(angle - 90))
arrow_head = [(base1_x, base1_y), (base2_x, base2_y), (end_x, end_y)]

arrow1 = my_canvas.create_polygon(arrow_head, fill='red')
arrow1 = change_angle(my_canvas, arrow1, 253, 144, 100, 210)

arrow2 = my_canvas.create_polygon(arrow_head, fill='red')
arrow2 = change_angle(my_canvas, arrow2, 770, 142, 100, 210)

arrow3 = my_canvas.create_polygon(arrow_head, fill='red')
arrow3 = change_angle(my_canvas, arrow3, 253, 406, 100, 210)

arrow4 = my_canvas.create_polygon(arrow_head, fill='red')
arrow4 = change_angle(my_canvas, arrow4, 770, 404, 100, 210)

# TWORZENIE POLA LOG
text_area = customtkinter.CTkTextbox(app_tk, wrap=tkinter.WORD, fg_color='black', text_color='white', width=200, height=100)
text_area.pack(expand=True, fill=tkinter.BOTH)
text_area.place(relx=0.5, rely=0.7, anchor=tkinter.CENTER)
scrollbar = customtkinter.CTkScrollbar(app_tk, command=text_area.yview)
text_area.configure(yscrollcommand=scrollbar.set)

# THEME COLORS
dark_theme_bg = "#1E1E1E"  # Kolor tła
dark_theme_fg = "#FFFFFF"  # Kolor tekstu

app_tk.configure(bg=dark_theme_bg)

app_tk.mainloop() 
